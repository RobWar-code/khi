Khi - a combative crossword game

Contents
    Introduction and Game Play
        Tile Capture
        End of Game Procedures
    Game Play Options
    User Options
    Technology
    Screen Layout
    Logic Flow
    Tile Play Actions
    Play Word Actions
    Computer Play
        Computer Turn
        Computer Word Selection 
        Test Setup
        First Word
        Nonfirst Words
            Outline
            Routines
            Search Start Letter Combinations

    Board Test Setup
    Word List and Word Indexing
    Schedule

<h1>Introduction and Game Play
    Khi is a board-based crossword game for two players (computer and human).
    With crosswords formed on a board of 19 x 19 squares.

    The aim of the game is for the two players to begin their crosswords
    on opposite sides of the board and to attempt to reach the opposite
    side before their opponent (or the tile hold is emptied for a draw). 
    Game points are achieved by capturing as many of the opponents tiles
    as possible.

    Letter tiles are dealt to each player, with the number of tiles being
    maintained at 7 as words are played to the board so long as enough
    tiles remain in the tile hold. The player has blue letter tiles and the 
    computer black. There are 120 tiles in the tile hold at the start.

    The start square at the centre of the opposite (horizontal) sides is
    marked with a star to represent the starting points for each player.
    The computer begins on the right, the player on the left.

    If a player cannot form a word he can pass. He may also change all
    of his letters for a penalty of 10 points.

<h2>Tile Capture
    A player must join new words to a letter of his own colour on the 
    board. When a player's new word crosses or forms a new word with tile(s)
    of the opponent's colours, the colours of the words formed or crossed
    are changed to that of the player.

    Crossed words only count in the direction of the letters layed, the first
    such direction if only a single tile is layed.

<h2>End of Game Procedures

    Edge of Board Reached
        When the gotWin flag is detected, the player is recorded and the game
        end panel is displayed. 

        The game end panel displays a table with the tile score, penalties,
        bonus and total scores.

        A message with "Computer Wins" or "You Win" is also displayed.

    Rack Cleared and Tile Hold Empty
        If, after their turn the computer or player rack is empty and
        the tile hold is empty, then the game ends. The player who
        first empties his rack gains a bonus of five points.

        The game over display is the same as for the board edge reached.

    Both Players Pass 
        The end panel is the same as for the other end scenarios, but
        there is no bonus.

<h1>Game Play Options
    The effectiveness of the computer player has two levels, Easy and Hard.
    These are presented as options at the start of the game.

    In the hard game, the computer selects upto 8 positions of its own 
    tiles toward the win edge of the board.

    In the easy game, the computer selects up to 5 own tile positions from
    the 12 nearest positions to the win edge.

    If there are less positions left than the given ideal, then the available
    are taken.

<h1>User Options
    The user options on the screen are:
        Pass
        Play Word
        Change Tiles
        Restart Game

    Pass Option
        If the game turn is zero, message the user and return
        
        When the pass option is clicked, any temporary tiles on the board are
        returned to the rack.

        If the passCount is greater than zero (that is the computer has passed),
        then the end of game procedure is called.

        Otherwise, the passCount is set to 1 and the main game.playWord() is called,
        this checks for the passCount and skips straight to the computer turn.

        If the computer does not pass, the passCount is reset to 0 after it's turn.

    Change Tiles Option
        If the rack has 1 or less tiles left, suggest a pass.

        Otherwise, clear any rack tiles on the board.

        Add the rack tiles to the tile hold and reshuffle.

        Select upto 7 new rack tiles (depending on the number in the hold).

        Redisplay the rack

        Add 10 points to the user's penalties

        Continue the turn

<h1>Technology
    HTML, CSS, Javascript, npm word-list

    Single HTML file for presentation.

<h1>Screen Layout
    When the game is first loaded a floating description of the
    game is displayed over the main board area, this has a 
    dismiss button to clear it.

    The main board display has a game title, 19 x 19 cell board,
    7 letter tile rack Play Word, Pass and Change Tiles buttons.
    A menu button with Game Scores.

    The game scores are displayed on a floating div and consists
    of two lists, player and computer.

<h1>Logic Flow
    When the page is loaded, the game initialisation procedures are
    run. These consist of:
        Load Word List 
        Draw Board
        Start Game
            The tile hold is filled
            The players' racks are filled from the tile hold.
            The player's tiles are displayed in the tile rack.
            The player has first turn. 
            The status bar prompts the player to make his move.

    When the page is first loaded the introduction panel is displayed.
    This is cleared when the user clicks its Dismiss button.
    Other buttons are disabled until this is done.

<h1>Tile Play Actions
    When a user clicks a rack tile:
        If another tile is already flagged, then cancel that flag
        and clear the highlight.
        Set the rack tile flag to the number of the clicked tile
        Highlight the clicked tile. 

    When the user clicks a square on the board:
        If no rack tile is current:
            If the square contains a temporary rack tile:
                Return it to the rack
            Otherwise:
                Ignore the click
        Otherwise:
            If the square contains any other tile:
                Ignore the click
            Otherwise:
                Record the tile positioned in the rackTilesSet data
                Set the square to contain the current rack tile
                Clear the highlight from the rack
                Put an empty cell in the rack

<h1>Play Word Actions
    When the Play Word option is used the letters placed - rack.lettersPlaced[0] array
    is checked.
    If no letters have been placed:
        Ignore the option
    Sort the letters placed array by x or y coordinate as the first two tiles
    have been layed.
    Scan the board along the line of the word from lowest to highest
    If there is an empty break in the word or the letters do not form an orthogonal:
        Inform the user and exit
    Count any non-temp letters in the scanned word.
    Count the non-temp own colour letters.
    Scan for connections adjoining each layed letter.
    Count the non-temp own colour letters of adjoining words.
    If the non-temp own colour count is zero:
        Inform the user and exit.
    Check the dictionary to see if the main scanned word exists
    If the main word does not exist:
        Inform the user and exit.
    Scan the adjoining intersections for words
    Record all word start and end cells
    Record the words that do not exist in the dictionary
    If any words do not appear in the dictionary:
        List and inform the user
        Exit.
    Scan all words crossed by the main word, record start
    and end positions

    Clear the temp flag for each letter layed from the board
    data.
    Clear the background highlight from each letter laid
    Change the background color of each newly created and

<h1>Computer Play

<h2>Computer Turn
    Set pass count = 0
    Set change count = 0
    Loop until a scoring word is found or the computer
    passes or the letter change count is reached
        If first word
            If there are no vowels
                Change the letters
                Increment the change letters count
            Else
                Initialise word scores
                do the first word selection
                If no word found
                    Change the letters
                    Add a penalty of ten points
                    Increment the change letters count
                Else
                    Set the word found flag
        Else
            Check whether there are any tiles in the rack
            Else
                Initialise word scores
                ...Do board scan etc.
                Decide on pass/change letters
    End Loop
    If the change letters count > max
        Send a message to the display
        Restart the game
    Else if the pass flag 
        Send a message to the display
        Increment the pass count
        Move to next turn
    Else
        Play the computer word to the board
        Check for winning move
        If not Winning Move
            Replenish the computer rack
            If there are no tiles left and the player has no tiles
                Message to the display


<h2>Computer Word Selection 

    In general computer word attempts are scored by the
    following:
        1) Number of opponent's tiles captured
        2) Proximity to winning edge (furthest left)
        3) Tally of letter scores, so that rare letters are used first

<h2>Test Setup

    Testing of the computer logic should be set-up using HTML
    cover scripts in the root directory, ie:
        testOps1.html 
        testOps2.html

<h2>First Word
    The first word composed by the computer ends on the
    starred square on the right hand side of the board.
    It is generally the longest word that can be formed
    from the left by playing the combination of letters.

    First check to see if there are any vowels in the
    set of letters "aeiouy*"

    If there are no vowels: 
        change the letters.
        start again
    
    Create a letter list of the rack tiles
    For each letter in the sorted list:
        If the letter is not the same as the last:
            Use this letter as the first letter
            Select the second letter from the other letters
            missing-out star chars if the first is a star

    Using the selected pair
    If the first is a star do the following for each letter
    of the alphabet, otherwise, use the pair.
        Search the two letter index for the pair
        If there is an entry for the pair:
            If the pair is a word, push the word onto the candidate stack
            and score it (addWordToCandidates())
            Make the three letter combinations from
            this pair and those remaining in the rack
            For each three letter combination
                Search the three letter index for the combination
                If the combination exists
                    If the set of three is a word - addWordToCandidates()
                    Make the four letter combinations from this
                    set of three
                    For each four letter combination
                        Search the four letter index
                        IF there are entries
                            If the four letter word exists - addWordToCandidates()
                            for each of the word list words with this combination
                                Check if the word is 7 or less letters
                                Check whether the remaining letters appear in the rack
                                Consume star letters when not
                                If word matched - addWordToCandidates
                    Next four letter combination allow for *
                else
                    Move to the next three letter combination (allow for *)
        else 
            Move to the next pair (allow for *)

    The levels of indexing can be handled by a recursive function

<h2>Nonfirst Words
    The general aim is search upto five own-tile locations for
    the best computer word score.

<h3>Outline
    board.initPlayPositions();
    let positionCount = 0;
    let positionFound = true;
    while (positionCount < this.maxPositionCount && positionFound) {
        // Get the next Playable Position
        let posObj = board.findPlayCell(this.playerNum);
        if (posObj.found) {
            get the position object from posObj
            for each valid position
                set-up the checkSet for the rack tiles
                let gotValidWords = []; // Flags for vertical ok and horizontal ok
                for each orthogonal direction (vertical, horizontal)
                    clear the test tiles from the board data
                    set tally of letters used
                    for each letter of the check set
                        if the letter has not already been used
                            loop through alphabet if a star
                                get the first test letter from the checkset
                                place the first test letter on the board data
                                scan the word starting at root position
                                if the test word is more than two chars long, flag it as compulsory
                                test whether the word exists or is found
                                if the word exists, add it to the high score
                                if the word is found as a start position
                                    while valid word and not all check set letters used and not board edge
                                        tag letter from the check set on to the end
                                        scan word in the orthogonal
                                        if the word is longer than the test word, adjust the test word
                                        scan word at the right angle
                                        if the right angle word is greater than 1 char 
                                            check whether it exists
                                            if it makes a new word, score it and and it to the new word list
                                        if it does not exist, withdraw the letter placed
                                        else 
                                            score the test word
                                            if the test word exists
                                                get the crossed words for this word 
                                                add it to the new words and hi-scores for this
                                                position

                                    // tag letters from the checkset on to the start of the original test word
                                    while checkset letters not all used and valid right-angle word
                                        add a letter from the check set to the start of the original test word
                                        scan the word in the orthogonal
                                        if the word is found
                                            scan the word from right angle from the letter
                                            if the length of the scanned word is greater than 1
                                            check whether the scanned word exists
                                            abandon this checkset letter
                                            else 
                                                save the new word
                                        
                                            if the letter position is valid
                                                check whether the orthogonal word exists
                                                if the orthogonal word exists
                                                    get crossed words
                                                    add the orthogonal word to the new words
                                                    add to hi scores

                                                add letters from the checkset to the end of the word




        }
        else {
            positionFound = false;
        }
    }

<h3>Routines
    playTurn() {
        gotWin = false;
        positionCount = 0;
        positionCellX = 0;
        positionCellY = -1;
        endOfPositions = false;
        while (positionCount < 10 && !endOfPositions) {
            // Get the next position
            let positionObj = board.findNextOwnCell(this.playerNum, positionCellX, positionCellY);
        }
    }
    
    board.findNextOwnCell(playerNum, positionCellX, positionCellY){

        const adj = {
            [-1, 0],
            [1, 0],
            [0, -1]
            [0, 1]
        }
        validCells: [
            // {cellX, cellY}
        ],
        // Look for own tile that can be joined to.
        // most leftward order first.
        let ownTileFound = false;
        let gotEdge = false;
        while (!ownTileFound && !gotEdge) {
            // Get next cell
            ++positionCellY;
            if (positionCellY >= this.boardHeight) {
                positionCellY = 0;
                ++positionCellX;
                if (positionCellX >= this.boardWidth) gotEdge = true;
            }
            if (!gotEdge) {
                // If own tile
                if (this.boardData[positionCellY][positionCellX].playerNum === playerNum) {
                    // Check the adjacent squares
                    for (let adjItem of adj) {
                        let cellX = positionCellX + adjItem[0];
                        let cellY = positionCellY + adjItem[1];
                        if (cellX >= 0 && cellX < this.boardWidth && cellY >= 0 && cellY < this.boardHeight) {
                            // Check whether empty cell
                            if (this.boardData[cellY][cellX].letter === "") {
                                validCells.push{cellX, cellY};
                            }
                        }
                    }
                    if (validCells.length > 0) {
                        ownTileFound = true;
                    }
                }
            }
        }
        return {gotEdge: gotEdge, ownTileFound: ownTileFound, validCells: validCells}
    }

    makeCheckSet() {
        let checkSet = [];
        // Add letters from rack, excluding stars
        for (let item of rack.racks[this.playerNum]) {
            if (item != "*" && item != "") {
                checkSet.push {
                    letter: item,
                    star: false,
                    currentSelection: -1,
                    selectionFlag: -1,
                }
            }
        }
        // Add in the stars
        for (let item of rack.racks[this.playerNum]) {
            if (item === "*") {
                checkSet.push {
                    letter: item,
                    star: true,
                    currentSelection: -1,
                    selectionFlag: -1,
                }
            }
        }
        return checkSet;
    }

    addLetters(levelData, ownCellX, ownCellY, adjCellX, adjCellY) {
        // Determine orthogonal
        let orthogonal = "vertical";
        if (adjCellX != ownCellX) orthogonal = "horizontal";
        // Get scan word data
        let scanObj = board.scanWord(ownCellX, ownCellY, orthogonal);
        // Check that scan word does not end at edge of board
        if ((orthogonal === "vertical" && scanObj.endY < board.boardHeight - 1) || 
            (orthogonal === "horizontal" && scanObj.endX < board.boardWidth - 1)) {
            // Set the level data for downward or rightward search
            // do the first checkSet
            let checkSet = makeCheckSet();
            levelData[0] = {
                checkSetPtr: -1,
                checkSet: checkSet,
                scanWord: scanObj.word,
                scanData: {
                    startX: scanObj.startX;
                    startY: scanObj.startY;
                    endX: scanObj.endX;
                    endY: scanObj.endY;
                }
                cellX: adjCellX;
                cellY: adjCellY;
            }
            let level = 0;
            let endObj = addEndLetters(levelData, level, orthogonal);
            // Check for got win
            // Prepare to do start chars
            // Do right angle
        }
        else {
            // Do the upward or leftward search
        }
    }

    addEndLetters(levelData, level, orthogonal) {
        /*
            levelData [ // upto rack.rackLength entries
                {
                    checkSet: {letter, star, currentSelection, selectionFlag},
                    charsUsed: "",
                    checkSetPtr: n,
                    scanWord: ,
                    scanWordData: ,
                    letter: ,
                    gotStar: ,
                    starLetterCount: ,
                    cellX: ,
                    cellY: 
                }
            ]
        */
        note: the scan word data should include the count of black and blue letters

        checkSet = levelData[level].checkSet;
        checkSetPtr = levelData[level].checkSetPtr;
        while !gotWin && not end of checkSet
            get next letter from checkSet
            loop on star
                next star char
                {gotWin, found, scanWord, scanWordData} = addEndLetter(levelData, level, orthogonal);
                if (found && !gotWin) {
                    checkSet[checkSetPtr].currentSelection = level;
                    {endOfLevels, beyondEdge} = getNextLevelCheckSet(levelData, level, orthogonal);
                    if (!endOfLetters && !beyondEdge) {
                        gotWin = addEndLetters (level + 1);
                    }
                }
                else if (!gotWin) {
                    get the next letter
                }
            if (!gotWin)
                level = level - 1
                return

        else (beyond edge) {
            --level
        }
    }

    getNextLevelCheckSet(levelData, level, orthogonal) {
        let newLevel = level + 1;
        if (newLevel >= rack.rackNumChars[this.playerNum]) {
            return {endOfLevels: true, beyondEdge: false};
        }
        // Get the new position from the scanWord data
        let endX = levelData[level].scanWordData.endX;
        let endY = levelData[level].scanWordData.endY;
        if (orthogonal === "vertical") {
            ++endY;
        }
        else {
            ++endX;
        }
        if (endX >= board.boardWidth || endY >= board.boardHeight) {
            return {endOfLevels: false, beyondEdge: true}
        }
        // Copy the checkSet from the old level
        let checkSet = json.parse(json.stringify(levelData[level].checkSet));
        // Clear selection Flags
        for (let item of checkSet) {
            item.selectionFlag = -1;
        }
        levelData[newLevel].checkSet = checkSet;
        levelData[newLevel].checkSetPtr = 0;
        levelData[newLevel].cellX = endX;
        levelData[newLevel].cellY = endY;
        levelData[newLevel].letter = "";
        return {endOfLevels: false, beyondEdge: false};
    }


    addEndLetter(levelData, level, orthogonal) {
        letter = levelData[level].letter;
        add the test letter to the board
        check the right-angle word
        if the right-angle word does not exist
            remove the test letter from the board
            return {gotWord: false, found: false}

        get the new scan word and scan data
        set found = false;
        set gotWord = true;
        set newScanWord = "";
        set newScanData = {};

        if the new scan word length is <= 4
            scan the indexes for the new scan word - set scanWordData
            if no match is found
                return {gotWord: false, found: false}
            if a word is found
                score it, and if it is the highest, save it
                set gotWord = true
                set found = true
            else
                set found = true
             
        else {
            select the first four letters of the scanWord
            search the index for the list of words matched
            if (wordList.length > 0) {
                search through the wordList for word beginning with the scan word
                if found {
                    set found = true;
                    if matched word
                        set gotWord = true;
                }
            }
        }
        return {gotWord: gotWord, found: found, newScanWord: newScanWord, newScanWordData: newScanWordData}            
        
    }

    scoreScanWord(levelData, level, word, orthogonal) {
        newWords = [];
        crossWords = [];

        get the letter score from checkSet

        get the scores for new words and crossed words
        for each cell letter of the scanWord
            scan the right-angle word
            if > 1 letter
                if the cell letter is black
                    add the right-angle word to the new words
                else
                    add the right-angle word to the cross words
                add the blue cell count for the right-angle word
                to the score
                save the left-most position of the right-angle word
                check whether the left-most position is zero
                if it is set the gotWin flag

        add the scanWord blue cell count to the score
        save the left-most position of the scan word
        if the left-most position is zero set the gotWin flag

        add the left-most position score to the score

        if the score is higher than the hiScore,
        record the hi details
        save/create the lettersPlaced data,

        return gotWin
    }

<h3>Search Start Letter Combinations
    layerData [
        {
            checkSet:,
            checkSetPtr:,
            charsUsed:,
            scanWord:,
            scanData:,
            cellX,
            cellY,
        }
    ]

    The data for each added start letter is recorded in the
    layerData array.

    doStartLetters(orthogonal) {
        Set-up the layerData and checkSet for the first letter
        while not end of first letter selection
            Add the first letter to the board
            scan the word
            Check whether the first letter placement makes a valid letter combination
            if a valid combination
                increment the layer
                set the new layer data and checkSet
                get the cellX, cellY positions from the scanData
                let addStartObj = addStartLetters(layerData, layer + 1, orthogonal)

            else
                choose the next letter from the checkSet
    }

    addStartLetters(layerData, layer, orthogonal) {
        while not end of checkSet
            get the next checkSet letter
            loop on star
                addStartLetter(layerData, layer, orthogonal)
    }

    addStartLetter(layerData, layer, orthogonal) {
        gotWin = false;
        check the rightangle scan word 
        if it does not exist 
            return
        
        get the scan word
        if it exists in the index or is found
            if gotWord {
                gotWin = score the word
            }
            if (!gotWin) {
                set-up the level data for the addEndLetters function
                // do the addEndLetters operation
                gotWin = addEndLetters(levelData, level, layer, orthogonal)
            }
        }
    }
    

<h1>Board Test Setup

    The board test setup is provided to enable the testing of
    computer play with different crossword configurations.

    The use of the board test data is established from index.html
    when the game is loaded.

    The board test data and routines are contained in the file
    src/boardTest.js.

    The routine responsible for loading the board test data and
    displaying it is boardTest.init()

    Data for the board is set out in an array of arrays of rows as 
    follows:

    testBoards [
        [
            "L0|  |  |  |  |A1 ..",
            ..
        ],
    ]

    Letters on the board are followed by the player number with a 
    dividing | with empty cells having two spaces.

    The board test data is scanned to make entries in board.boardData
    table data. Letters are withdrawn from the tileset (allowing for stars)
    as they are placed in the board data.

    The game turn number is given by the programmer with the data.

    It is assumed that the next turn is the user's turn, with the
    computer play occurring subsequently.

<h1>Word List and Word Indexing

    The word list used is that supplied from npm. This is
    a lowercase list of English words that excludes single
    letter words.

    Three indexes are built from the word list, using the
    initial 2, 3 and 4 characters of each word of the 
    word list. The lengths of these indexes are 26 ^ n
    items and allow for the calculation of the keyed
    index offset. Word list pointers in the indexes are 
    either null or point to the array offset of the
    start of the matched set.

    A general purpose word search is supplied which
    checks the length of the word to decide which
    index to use.

    Note that it may be better to supply the indexes
    pre-built.

<h1>Schedule

Start Date: 08/10/2025

                                    Est              Actual
Board and Rack Layout               2 days           2 days
Board Play                          1 day            1 day
Player Tiles Played Validation      3 days           3 days
Word list and indexing              3 days           3 days
Computer turns                      14 days          16 days
User Options                        6 days
Trials and Adjustments              10 days
Systems Test Design                 3 days
Systems Test Implement              3 days
